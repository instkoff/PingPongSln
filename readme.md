Решение состоит из 5 проектов:
1) PingApp - Консольное приложение. Клиент для сервиса.
2) PingPong.Shared - Библиотека с моделями нужными как для сервиса, так и для клиента.
3) PongApp - Основной запускаемый проект сервиса.
4) PongApp.Domain - Библиотека с основной бизнес логикой сервиса.
5) PongApp.DataAccess - Библиотека с логикой для доступа к данным.

Порядок запуска:
1) Скомпилировать сервис PongApp. В файле appsettings.json можно настроить путь к базе и настройки логирования. 
По умолчанию база создается автоматически при старте приложения в той же папке откуда запущена программа.
2) Запустить сервис PongApp.
3) Скомпилировать клиент PingApp.
4) При необходимости поправить файл конфигурации. Можно указать имя пользователя, адрес сервиса, настройки прокси.
5) Запустить PingApp и следовать пунктам меню.

В сервисе реализовано логирование, настройки храняться в appsettings.json. 
По умолчанию все информационные сообщения выводятся в консоль, ворнинги и ошибки дополнительно пишутся в файл в директории Logs.

В сервисе настроен Swagger для тестирования API. Расоположен по адресу https://localhost:5001/swagger/index.html

В сервисе предусмотрена возможность мониторинга состояния, текущее состояние можно получить при помощи встроенного UI расположенного по адресу:
https://localhost:5001/healthchecks-ui#/healthchecks
для примера добавлена проверка на возможность подключения к базе. При желании можно написать и добавить другие виды проверок.
Так же получить состояние сервиса можно из клиентского приложения PingApp.

При старте сервиса автоматически создается файл с БД и накатывается последняя миграция. (В боевых условия я бы так конечно делать не стал...)

В клиенте в файле конфигурации appsettings.json задается имя пользователя, в последствии просматривать и удалять сообщения возможно только у того пользователя который указан в конфигурации.
Сообщения создаются так же от имени этого пользователя.

В клиенте предусмотрена возможность настроить прокси сервер через файл конфигурации.

Из собственных мыслей хочу сказать, что некоторые вещи довольно избыточни для такого проекта, но я старался показать максимально всё, с чем имел опыт или изучал.
Так же по моему мнению я бы сделал микросервисную часть с использованием gRPC. Он быстрее, поддерживает потоковыю передачу и более легковесный. Но это мое личное мнение :)
В качестве доступа к данным можно было использовать паттерн "Репозитарий" но вокруг него в много разногласий. Кто-то говорит, что он не нужен, кто то наоборот. В этот раз решил попробовать без него :)
